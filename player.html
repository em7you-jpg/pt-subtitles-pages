<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PT Subtitles</title>
  <style>
    /* OBS용: 배경 투명 + 가장 단순한 레이아웃 */
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }
    .wrap {
      position: absolute;
      left: 40px;
      right: 40px;
      bottom: 30px;
      display: flex;
      justify-content: center;
      pointer-events: none;
    }
    .subtitle {
      display: inline-block;
      padding: 14px 18px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 16px;
      line-height: 1.25;
      text-align: center;
      white-space: pre-wrap;
      word-break: keep-all;
      text-shadow: 0 2px 12px rgba(0,0,0,0.55);
      min-height: 1.25em;
    }
    /* 디버그용(필요 없으면 숨겨도 됨) */
    .debug {
      position: absolute;
      left: 12px;
      top: 12px;
      font-size: 14px;
      color: rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.35);
      padding: 6px 8px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div class="debug" id="debug">loading…</div>
  <div class="wrap">
    <div class="subtitle" id="subtitle"></div>
  </div>

  <script>
    // ===== 설정 =====
    const qs = new URLSearchParams(location.search);

// 기본값(필요하면 URL로 덮어씀)
const TRACK_URL = qs.get("track") || "/track.json";
const POLL_MS   = Number(qs.get("poll") || "1000");
const USE_LANG  = qs.get("lang") || "ja";     // ja | ko

// 레이아웃 파라미터
const LEFT   = Number(qs.get("left")   || "40");   // px
const RIGHT  = Number(qs.get("right")  || "40");   // px
const BOTTOM = Number(qs.get("bottom") || "30");   // px
const FS     = Number(qs.get("fs")     || "16");   // px
const PAD_Y  = Number(qs.get("py")     || "14");   // px
const PAD_X  = Number(qs.get("px")     || "18");   // px
const BG     = Number(qs.get("bg")     || "0.55"); // 0~1
const DEBUG  = (qs.get("debug") || "1") !== "0";   // debug=0 이면 숨김

// 적용
const wrap = document.querySelector(".wrap");
wrap.style.left = LEFT + "px";
wrap.style.right = RIGHT + "px";
wrap.style.bottom = BOTTOM + "px";

const sub = document.getElementById("subtitle");
sub.style.fontSize = FS + "px";
sub.style.padding = `${PAD_Y}px ${PAD_X}px`;
sub.style.background = `rgba(0,0,0,${BG})`;

const dbg = document.getElementById("debug");
dbg.style.display = DEBUG ? "block" : "none";

    // ===============

    let track = null;
    let lastTrackText = "";
    let lastShownIndex = -1;

    function nowSec() {
      // OBS Browser Source는 실시간 스트림과 직접 동기화가 어려움.
      // 1단계에서는 "track.json 업데이트가 잘 되는지" 확인 목적이라
      // 일단 '마지막 라인'을 보여주는 방식(=가장 안정적인 가시성)으로 시작.
      return Date.now() / 1000;
    }

    function pickText(line) {
      if (!line) return "";
      if (USE_LANG === "ko") return (line.ko && line.ko.trim()) ? line.ko : "";
      return (line.ja && line.ja.trim()) ? line.ja : "";
    }

    function render() {
      const el = document.getElementById("subtitle");
      const dbg = document.getElementById("debug");

      if (!track || !Array.isArray(track.lines)) {
        el.textContent = "";
        dbg.textContent = "track: none";
        return;
      }

      // (Stage-1 최우선) "정상 동작"이 보이게: 마지막 라인 표시
      const lines = track.lines;
      const idx = lines.length ? (lines.length - 1) : -1;

      if (idx !== lastShownIndex) lastShownIndex = idx;

      const text = idx >= 0 ? pickText(lines[idx]) : "";
      el.textContent = text || "";

      // 디버그 표시
      const title = track.title || "";
      const size = JSON.stringify(track).length;
      dbg.textContent = `ok | title=${title} | lines=${lines.length} | bytes=${size} | updated=${new Date().toLocaleTimeString()}`;
    }

    async function fetchTrack() {
      const dbg = document.getElementById("debug");
      try {
        const res = await fetch(TRACK_URL + "?t=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const json = await res.json();

        const text = JSON.stringify(json);
        if (text !== lastTrackText) {
          lastTrackText = text;
          track = json;
          render();
        }
      } catch (e) {
        dbg.textContent = "fetch error: " + (e && e.message ? e.message : String(e));
      }
    }

    // 시작
    fetchTrack();
    setInterval(fetchTrack, POLL_MS);
  </script>
</body>
</html>
