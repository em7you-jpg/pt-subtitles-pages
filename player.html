<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PT Player</title>
  <style>
    :root{
      --font: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Noto Sans JP", sans-serif;

      /* ---------- title (TOP) ---------- */
      --titleSize: 22px;
      --titleGap: 10px;
      --titleOpacity: 0.92;
      --titleTop: 4em; /* ✅ 상단 간격: "4줄 정도" */

      /* ---------- subtitles (HALF SIZE DEFAULT) ---------- */
      --jaSize: 26px;  /* ✅ 34 -> 24 */
      --koSize: 20px;  /* ✅ 26 -> 18 */
      --lineGap: 14px;

      --bg: rgba(0,0,0,0.0);
      --fg: rgba(255,255,255,0.95);
      --shadow: 0 2px 12px rgba(0,0,0,0.55);
      --pad: 14px;
      --radius: 14px;
      --posX: 50%;
      --posY: 82%;
      --align: center; /* left|center|right */
      --maxW: 92vw;
    }
    body{
      margin:0; background: transparent; overflow:hidden;
      font-family: var(--font);
    }

    /* ---------- TOP TITLE WRAP ---------- */
    #titleWrap{
      position: fixed;
      left: 50%;
      top: var(--titleTop);
      transform: translateX(-50%);
      width: min(92vw, 980px);
      color: var(--fg);
      text-align: center;
      pointer-events: none;
      filter: drop-shadow(var(--shadow));
    }
    #title{
      font-size: var(--titleSize);
      font-weight: 800;
      line-height: 1.2;
      opacity: var(--titleOpacity);
      margin: 0 0 var(--titleGap) 0;
      letter-spacing: 0.2px;
      word-break: keep-all;
    }
    .title-off #titleWrap{ display:none; }

    /* ---------- SUBTITLE WRAP (BOTTOM) ---------- */
    #wrap{
      position: fixed;
      left: var(--posX);
      top: var(--posY);
      transform: translate(-50%,-50%);
      width: var(--maxW);
      color: var(--fg);
      text-align: var(--align);
      pointer-events: none; /* OBS에서 클릭 안 막기 */
    }
    #box{
      display:inline-block;
      background: var(--bg);
      padding: var(--pad);
      border-radius: var(--radius);
      filter: drop-shadow(var(--shadow));
      pointer-events: auto; /* 컨트롤 영역만 클릭 */
    }

    .ja{ font-size: var(--jaSize); font-weight: 700; line-height: 1.25; }
    .ko{ font-size: var(--koSize); font-weight: 600; line-height: 1.25; opacity: 0.92; margin-top: var(--lineGap); }

    #hud{
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.85;
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap: wrap;
      user-select: none;
    }
    #hud button, #hud input{
      pointer-events: auto;
      font-size: 13px;
    }
    #hud button{
      border: 0;
      border-radius: 10px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.95);
      cursor:pointer;
    }
    #hud button:hover{ background: rgba(255,255,255,0.18); }
    #hud .pill{
      background: rgba(255,255,255,0.10);
      padding: 6px 10px;
      border-radius: 10px;
    }
    #audio{
      width: min(720px, 86vw);
    }
    /* OBS에서 HUD 숨기고 싶으면 ?hud=0 */
    .hud-off #hud{ display:none; }
  </style>
</head>
<body>

  <!-- ✅ Title fixed at TOP -->
  <div id="titleWrap">
    <div id="title"></div>
  </div>

  <!-- Subtitles + HUD -->
  <div id="wrap">
    <div id="box">
      <div id="ja" class="ja"></div>
      <div id="ko" class="ko" style="display:none;"></div>

      <div id="hud">
        <button id="btnPrev">Prev</button>
        <button id="btnPlay">Play</button>
        <button id="btnNext">Next</button>

        <span class="pill">Track: <span id="trackLabel">-</span></span>
        <span class="pill">Offset: <span id="offsetLabel">0.0</span>s</span>

        <button id="btnOffM">-0.5s</button>
        <button id="btnOffP">+0.5s</button>

        <audio id="audio" controls preload="auto" crossorigin="anonymous"></audio>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);
  const params = new URLSearchParams(location.search);

  const setId = params.get("set") || "default";
  const lang = (params.get("lang") || "both").toLowerCase(); // both|ja|ko
  const hud = params.get("hud"); // 0 => hide
  const cacheBust = params.get("cb") || ""; // optional external cache buster

  // ✅ 간주/무가사 구간에서 "마지막 가사 잔상" 제거용 hold (초)
  // - hold=0 이면 즉시 공백
  // - 기본 1.2초 (너무 딱 끊기지 않게)
  const maxHold = (() => {
    const v = params.get("hold");
    const n = Number(v);
    if (v === null) return 1.2;
    return Number.isFinite(n) ? Math.max(0, n) : 1.2;
  })();

  // title show/hide
  const titleOn = (params.get("title") ?? "1") !== "0";
  if (!titleOn) document.body.classList.add("title-off");

  if (hud === "0") document.body.classList.add("hud-off");

  function num(v, d){ const n = Number(v); return Number.isFinite(n) ? n : d; }

  // style params (기존 player의 URL 제어 감각 그대로 유지)
  const cssVars = {
    "--posX": params.get("x") ? params.get("x") + "%" : null,
    "--posY": params.get("y") ? params.get("y") + "%" : null,
    "--jaSize": params.get("jaSize") ? params.get("jaSize") + "px" : null,
    "--koSize": params.get("koSize") ? params.get("koSize") + "px" : null,
    "--align": params.get("align") || null,
    "--maxW": params.get("maxW") ? params.get("maxW") + "vw" : null,

    // title style params
    "--titleSize": params.get("titleSize") ? params.get("titleSize") + "px" : null,
    "--titleGap": params.get("titleGap") ? params.get("titleGap") + "px" : null,
    "--titleOpacity": params.get("titleOpacity") ? params.get("titleOpacity") : null,
    "--titleTop": params.get("titleTop") ? params.get("titleTop") + "em" : null,
  };
  for (const [k,v] of Object.entries(cssVars)) if (v) document.documentElement.style.setProperty(k, v);

  const titleEl = $("title");
  const jaEl = $("ja");
  const koEl = $("ko");
  const audio = $("audio");

  const btnPrev = $("btnPrev");
  const btnPlay = $("btnPlay");
  const btnNext = $("btnNext");
  const btnOffM = $("btnOffM");
  const btnOffP = $("btnOffP");
  const trackLabel = $("trackLabel");
  const offsetLabel = $("offsetLabel");

  // offset per set
  const lsKey = `pt_offset_${setId}`;
  let offsetSec = num(localStorage.getItem(lsKey), 0.0);
  function setOffset(v){
    offsetSec = Math.round(v * 10) / 10;
    localStorage.setItem(lsKey, String(offsetSec));
    offsetLabel.textContent = offsetSec.toFixed(1);
  }
  setOffset(offsetSec);

  function withCB(url){
    const u = new URL(url, location.origin);
    // 항상 캐시 우회: set별 최신 반영
    u.searchParams.set("v", cacheBust || Date.now().toString());
    return u.toString();
  }

  async function fetchJSON(url){
    const res = await fetch(withCB(url), {cache:"no-store"});
    if (!res.ok) throw new Error(`fetch failed: ${res.status} ${url}`);
    return await res.json();
  }

  // ---------- cue extraction (format-agnostic) ----------
  // track json 포맷이 약간 달라도 start/end + text/ja/ko를 찾도록 "느슨하게" 처리
  function extractCues(obj){
    const cues = [];
    const seen = new Set();

    function pushCue(s,e,ja,ko){
      s = Number(s); e = Number(e);
      if (!Number.isFinite(s) || !Number.isFinite(e) || e <= s) return;
      ja = (ja ?? "").toString().trim();
      ko = (ko ?? "").toString().trim();
      if (!ja) return; // ✅ 빈 자막 라인은 cue로 취급하지 않음
      const key = `${s.toFixed(3)}|${e.toFixed(3)}|${ja}`;
      if (seen.has(key)) return;
      seen.add(key);
      cues.push({start:s, end:e, ja, ko});
    }

    function walk(x){
      if (!x) return;
      if (Array.isArray(x)){
        for (const it of x) walk(it);
        return;
      }
      if (typeof x === "object"){
        // common variants
        if (("start" in x) && ("end" in x)){
          const ja = x.ja ?? x.text ?? x.line ?? x.content ?? "";
          const ko = x.ko ?? x.ko_text ?? "";
          pushCue(x.start, x.end, ja, ko);
        }
        if (("t0" in x) && ("t1" in x)){
          const ja = x.ja ?? x.text ?? x.s ?? "";
          const ko = x.ko ?? "";
          pushCue(x.t0, x.t1, ja, ko);
        }
        for (const v of Object.values(x)) walk(v);
      }
    }
    walk(obj);

    cues.sort((a,b)=>a.start-b.start);
    return cues;
  }

  // ✅ end 범위 기반: start<=t<end 이면 표시, 아니면 null
  let lastCueIdx = 0;
  function cueAt(cues, t){
    if (!cues || cues.length === 0) return null;

    // try from last index forward
    for (let i = lastCueIdx; i < cues.length; i++){
      const c = cues[i];
      if (t < c.start) break;
      if (t >= c.start && t < c.end){
        lastCueIdx = i;
        return c;
      }
    }
    // try backward (when seeked)
    for (let i = Math.min(lastCueIdx, cues.length - 1); i >= 0; i--){
      const c = cues[i];
      if (t >= c.start && t < c.end){
        lastCueIdx = i;
        return c;
      }
      if (t > c.end && i === cues.length - 1) break;
    }
    return null;
  }

  function clearSubtitle(){
    if (jaEl.textContent !== "") jaEl.textContent = "";
    if (koEl.textContent !== "") koEl.textContent = "";
    koEl.style.display = "none";
  }

  // ---------- playlist handling ----------
  const base = `${location.origin}/set/${encodeURIComponent(setId)}/`;
  const playlistUrl = base + "playlist.json";

  let playlist = null;
  let idx = 0;
  let cues = [];
  let currentTrack = null;

  function updateTrackLabel(){
    if (!currentTrack){ trackLabel.textContent = "-"; return; }
    trackLabel.textContent = `${currentTrack.id}${currentTrack.title ? " · " + currentTrack.title : ""}`;
  }

  function setHeaderTitle(text){
    if (!titleEl) return;
    const t = (text ?? "").toString().trim();
    titleEl.textContent = t;
    if (t) document.title = `PT Player — ${t}`;
  }

  // ✅ PATCH: rAF render loop (단 1개만 유지)
  let rafId = null;
  function startRenderLoop(){
    stopRenderLoop();
    const loop = () => {
      // 재생 중에만 도는 루프
      if (!audio.paused && !audio.ended) {
        render();
        rafId = requestAnimationFrame(loop);
      } else {
        rafId = null;
      }
    };
    rafId = requestAnimationFrame(loop);
  }
  function stopRenderLoop(){
    if (rafId !== null){
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  }

  // ✅ PATCH: 트랙 로드 경쟁 방지 토큰
  let loadSeq = 0;
  let isLoading = false;

  function setLoading(on){
    isLoading = on;
    btnPrev.disabled = on;
    btnNext.disabled = on;
    // Play는 누를 수 있게 두되, 로딩 중엔 무의미하니 UX상 막고 싶으면 아래 주석 해제
    // btnPlay.disabled = on;
  }

  // ✅ PATCH: 간주 잔상 제거용 상태
  let lastCueEnd = 0;

  async function loadTrack(i){
    if (!playlist) return;
    const mySeq = ++loadSeq;

    setLoading(true);

    // 루프/자막/상태를 "확정적으로" 초기화
    stopRenderLoop();
    lastCueEnd = 0;
    lastCueIdx = 0;
    cues = [];
    clearSubtitle();

    // 오디오를 멈추고 교체(트랙 전환 중 timeupdate/렌더로 꼬이는 것 방지)
    try { audio.pause(); } catch {}

    idx = Math.max(0, Math.min(i, playlist.tracks.length-1));
    currentTrack = playlist.tracks[idx];
    updateTrackLabel();

    // set audio source
    if (!currentTrack.audio_url) throw new Error("missing audio_url");
    audio.src = currentTrack.audio_url;

    // load track json cues
    if (!currentTrack.track_url) throw new Error("missing track_url");
    const trackJson = await fetchJSON(base + currentTrack.track_url);

    // ✅ 경쟁 방지: 내가 최신 요청이 아니면 여기서 중단
    if (mySeq !== loadSeq) return;

    // title priority: track.title -> trackJson.title -> empty
    const t = (currentTrack && currentTrack.title) ? currentTrack.title : (trackJson && trackJson.title) ? trackJson.title : "";
    if (titleOn) setHeaderTitle(t);

    cues = extractCues(trackJson);
    lastCueIdx = 0;
    lastCueEnd = 0;

    // clear text immediately
    clearSubtitle();

    // 로딩 종료
    setLoading(false);

    // 플레이 중이면 루프는 play 이벤트에서 시작되지만,
    // 로딩 완료 직후 render 1회 실행은 즉시 반영에 도움
    render();
  }

  function render(){
    if (!cues || cues.length === 0){
      clearSubtitle();
      return;
    }

    const t = audio.currentTime + offsetSec;
    const c = cueAt(cues, t);

    // ✅ active cue 없으면:
    // - hold=0 이면 즉시 공백
    // - 아니면 lastCueEnd 이후 maxHold 지나면 공백 (간주 잔상 제거)
    if (!c){
      if (t > (lastCueEnd + maxHold)) clearSubtitle();
      return;
    }

    // cue가 있으면 lastCueEnd 갱신
    lastCueEnd = c.end;

    // JA always
    if (jaEl.textContent !== c.ja) jaEl.textContent = c.ja;

    // KO: only show if exists and lang=both|ko
    const hasKo = !!(c.ko && c.ko.trim());
    if ((lang === "both" || lang === "ko") && hasKo){
      const target = (lang === "ko") ? c.ko : c.ko;
      if (koEl.textContent !== target) koEl.textContent = target;
      koEl.style.display = "";
    } else {
      koEl.textContent = "";
      koEl.style.display = "none";
    }
  }

  // ---------- controls ----------
  btnPlay.addEventListener("click", async () => {
    if (!playlist || isLoading) return;
    if (audio.paused) await audio.play();
    else audio.pause();
  });
  audio.addEventListener("play", ()=> {
    btnPlay.textContent = "Pause";
    startRenderLoop(); // ✅ PATCH: 재생 시작 시 rAF 루프 시작
  });
  audio.addEventListener("pause", ()=> {
    btnPlay.textContent = "Play";
    stopRenderLoop();  // ✅ PATCH: 일시정지 시 루프 정지
    render();          // 정지 상태에서도 최종 프레임 반영
  });

  btnPrev.addEventListener("click", async () => {
    if (isLoading) return;
    await loadTrack(idx - 1);
    // 최신 로드가 아니면 play 하지 않음
    await audio.play();
  });
  btnNext.addEventListener("click", async () => {
    if (isLoading) return;
    await loadTrack(idx + 1);
    await audio.play();
  });

  btnOffM.addEventListener("click", ()=> setOffset(offsetSec - 0.5));
  btnOffP.addEventListener("click", ()=> setOffset(offsetSec + 0.5));

  // hotkeys
  window.addEventListener("keydown", (e)=>{
    if (e.key === "ArrowLeft") btnPrev.click();
    if (e.key === "ArrowRight") btnNext.click();
    if (e.key === "ArrowDown") setOffset(offsetSec - 0.5);
    if (e.key === "ArrowUp") setOffset(offsetSec + 0.5);
    if (e.key === " "){ e.preventDefault(); btnPlay.click(); }
  });

  // ✅ PATCH: timeupdate 의존도 낮추기 (rAF가 주력)
  // seeked/loadedmetadata에서는 즉시 1회 render
  audio.addEventListener("seeked", render);
  audio.addEventListener("loadedmetadata", render);

  audio.addEventListener("ended", async () => {
    stopRenderLoop();
    // auto next
    if (!playlist) return;
    if (idx < playlist.tracks.length-1){
      await loadTrack(idx + 1);
      await audio.play();
    } else {
      // 마지막 트랙 끝나면 자막 비우기
      clearSubtitle();
    }
  });

  // ---------- boot ----------
  (async () => {
    playlist = await fetchJSON(playlistUrl);

    if (!playlist || !Array.isArray(playlist.tracks) || playlist.tracks.length === 0){
      throw new Error("playlist.json invalid or empty");
    }

    // optional start track: ?i=1 (1-based)
    const startI = num(params.get("i"), 1);
    await loadTrack(startI - 1);

    // auto play: ?autoplay=1
    if (params.get("autoplay") === "1"){
      await audio.play();
    }

    updateTrackLabel();
    offsetLabel.textContent = offsetSec.toFixed(1);
  })().catch(err => {
    clearSubtitle();
    jaEl.textContent = "PLAYER ERROR";
    koEl.style.display = "";
    koEl.textContent = String(err?.message || err);
    console.error(err);
  });

})();
</script>
</body>
</html>
