<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PT Subtitles</title>
  <style>
    /* OBS용: 배경 투명 + 가장 단순한 레이아웃 */
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }
    .wrap {
      position: absolute;
      left: 40px;
      right: 40px;
      bottom: 80px;
      display: flex;
      justify-content: center;
      pointer-events: none;
    }
    .subtitle {
      display: inline-block;
      padding: 14px 18px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 44px;
      line-height: 1.25;
      text-align: center;
      white-space: pre-wrap;
      word-break: keep-all;
      text-shadow: 0 2px 12px rgba(0,0,0,0.55);
      min-height: 1.25em;
    }
    /* 디버그용(필요 없으면 숨겨도 됨) */
    .debug {
      position: absolute;
      left: 12px;
      top: 12px;
      font-size: 14px;
      color: rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.35);
      padding: 6px 8px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div class="debug" id="debug">loading…</div>
  <div class="wrap">
    <div class="subtitle" id="subtitle"></div>
  </div>

  <script>
    // ===== 설정 =====
    const TRACK_URL = "/track.json";   // Pages 같은 도메인
    const POLL_MS = 1000;              // 1초마다 갱신
    const USE_LANG = "ja";             // "ja" 또는 "ko"
    // ===============

    let track = null;
    let lastTrackText = "";
    let lastShownIndex = -1;

    function nowSec() {
      // OBS Browser Source는 실시간 스트림과 직접 동기화가 어려움.
      // 1단계에서는 "track.json 업데이트가 잘 되는지" 확인 목적이라
      // 일단 '마지막 라인'을 보여주는 방식(=가장 안정적인 가시성)으로 시작.
      return Date.now() / 1000;
    }

    function pickText(line) {
      if (!line) return "";
      if (USE_LANG === "ko") return (line.ko && line.ko.trim()) ? line.ko : "";
      return (line.ja && line.ja.trim()) ? line.ja : "";
    }

    function render() {
      const el = document.getElementById("subtitle");
      const dbg = document.getElementById("debug");

      if (!track || !Array.isArray(track.lines)) {
        el.textContent = "";
        dbg.textContent = "track: none";
        return;
      }

      // (Stage-1 최우선) "정상 동작"이 보이게: 마지막 라인 표시
      const lines = track.lines;
      const idx = lines.length ? (lines.length - 1) : -1;

      if (idx !== lastShownIndex) lastShownIndex = idx;

      const text = idx >= 0 ? pickText(lines[idx]) : "";
      el.textContent = text || "";

      // 디버그 표시
      const title = track.title || "";
      const size = JSON.stringify(track).length;
      dbg.textContent = `ok | title=${title} | lines=${lines.length} | bytes=${size} | updated=${new Date().toLocaleTimeString()}`;
    }

    async function fetchTrack() {
      const dbg = document.getElementById("debug");
      try {
        const res = await fetch(TRACK_URL + "?t=" + Date.now(), { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const json = await res.json();

        const text = JSON.stringify(json);
        if (text !== lastTrackText) {
          lastTrackText = text;
          track = json;
          render();
        }
      } catch (e) {
        dbg.textContent = "fetch error: " + (e && e.message ? e.message : String(e));
      }
    }

    // 시작
    fetchTrack();
    setInterval(fetchTrack, POLL_MS);
  </script>
</body>
</html>
